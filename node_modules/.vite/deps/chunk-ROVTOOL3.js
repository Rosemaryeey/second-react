// node_modules/preline/src/utils/index.ts
var stringToBoolean = (string) => {
  return string === "true" ? true : false;
};
var getClassProperty = (el, prop, val = "") => {
  return (window.getComputedStyle(el).getPropertyValue(prop) || val).replace(
    " ",
    ""
  );
};
var getClassPropertyAlt = (el, prop, val = "") => {
  let targetClass = "";
  el.classList.forEach((c) => {
    if (c.includes(prop)) {
      targetClass = c;
    }
  });
  return targetClass.match(/:(.*)]/) ? targetClass.match(/:(.*)]/)[1] : val;
};
var isIOS = () => {
  if (/iPad|iPhone|iPod/.test(navigator.platform)) {
    return true;
  } else {
    return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);
  }
};
var isIpadOS = () => {
  return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);
};
var isDirectChild = (parent, child) => {
  const children = parent.children;
  for (let i = 0; i < children.length; i++) {
    if (children[i] === child)
      return true;
  }
  return false;
};
var isEnoughSpace = (el, toggle, preferredPosition = "auto", space = 10, wrapper = null) => {
  const referenceRect = toggle.getBoundingClientRect();
  const wrapperRect = wrapper ? wrapper.getBoundingClientRect() : null;
  const viewportHeight = window.innerHeight;
  const spaceAbove = wrapperRect ? referenceRect.top - wrapperRect.top : referenceRect.top;
  const spaceBelow = (wrapper ? wrapperRect.bottom : viewportHeight) - referenceRect.bottom;
  const minimumSpaceRequired = el.clientHeight + space;
  if (preferredPosition === "bottom") {
    return spaceBelow >= minimumSpaceRequired;
  } else if (preferredPosition === "top") {
    return spaceAbove >= minimumSpaceRequired;
  } else {
    return spaceAbove >= minimumSpaceRequired || spaceBelow >= minimumSpaceRequired;
  }
};
var isFormElement = (target) => {
  return target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement;
};
var isParentOrElementHidden = (element) => {
  if (!element)
    return false;
  const computedStyle = window.getComputedStyle(element);
  if (computedStyle.display === "none")
    return true;
  return isParentOrElementHidden(element.parentElement);
};
var debounce = (func, timeout = 200) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(void 0, args);
    }, timeout);
  };
};
var dispatch = (evt, element, payload = null) => {
  const event = new CustomEvent(evt, {
    detail: { payload },
    bubbles: true,
    cancelable: true,
    composed: false
  });
  element.dispatchEvent(event);
};
var afterTransition = (el, callback) => {
  const handleEvent = () => {
    callback();
    el.removeEventListener("transitionend", handleEvent, true);
  };
  const computedStyle = window.getComputedStyle(el);
  const transitionDuration = computedStyle.getPropertyValue(
    "transition-duration"
  );
  const transitionProperty = computedStyle.getPropertyValue(
    "transition-property"
  );
  const hasTransition = transitionProperty !== "none" && parseFloat(transitionDuration) > 0;
  if (hasTransition)
    el.addEventListener("transitionend", handleEvent, true);
  else
    callback();
};
var htmlToElement = (html) => {
  const template = document.createElement("template");
  html = html.trim();
  template.innerHTML = html;
  return template.content.firstChild;
};
var classToClassList = (classes, target, splitter = " ", action = "add") => {
  const classesToArray = classes.split(splitter);
  classesToArray.forEach(
    (cl) => action === "add" ? target.classList.add(cl) : target.classList.remove(cl)
  );
};
var menuSearchHistory = {
  historyIndex: -1,
  addHistory(index) {
    this.historyIndex = index;
  },
  existsInHistory(index) {
    return index > this.historyIndex;
  },
  clearHistory() {
    this.historyIndex = -1;
  }
};

export {
  stringToBoolean,
  getClassProperty,
  getClassPropertyAlt,
  isIOS,
  isIpadOS,
  isDirectChild,
  isEnoughSpace,
  isFormElement,
  isParentOrElementHidden,
  debounce,
  dispatch,
  afterTransition,
  htmlToElement,
  classToClassList,
  menuSearchHistory
};
/*! Bundled license information:

preline/src/utils/index.ts:
  (*
   * @version: 2.5.0
   * @author: Preline Labs Ltd.
   * @license: Licensed under MIT and Preline UI Fair Use License (https://preline.co/docs/license.html)
   * Copyright 2024 Preline Labs Ltd.
   *)
*/
//# sourceMappingURL=chunk-ROVTOOL3.js.map
